Why our 256-bit (YMM) demo is tricky

AVX is meant for packed data. Many scalar converts exist only in 128-bit form (e.g., _mm_cvtsi32_sd, _mm_cvtsi64_ss). There is no _mm256_cvtsi32_sd.

If you only have single values (one i,d,l,f), using YMM gives no benefit—you end up widening 128-bit work or shuffling, which is pointless.

To truly use 256-bit, you must compute 4 doubles (or 8 floats) at once from arrays; otherwise stick to SSE2 scalar ops.

Mixing SSE and AVX inside one function on some older Intel CPUs caused penalties (“domain transition”) unless everything is VEX-encoded—another reason to avoid fake 256-bit demos.

Portability: AVX requires -mavx (or /arch:AVX) and CPU/OS support. Always keep a scalar fallback.

Takeaway:
Use AVX (256-bit) when you have packed vectors/arrays. For single scalars, SSE2 scalar intrinsics are the right tool and map cleanly to the assembly we showed.